{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pySNOW","text":"<p>pySNOW (Software Nano Object Workflow) is a set of Python  tools for the structural analysis of atomic configurations originating from MD and other atomistic simulations. The code is freely available on GitHub.</p> <ul> <li> GitHub Get pySnow on GitHub </li> </ul> <pre><code>#example: reading an xyz and computing the aGCN and writing the per-atom aGCN to an xyz\nfrom snow.lodispp.pp_io import read_xyz, write_xyz\nfrom snow.descriptors.gcn import agcn_calculator\n\nel, sys_coords = read_xyz(filename = \"Au561_Ih.xyz\")\nagcn = agcn_calculator(index_frame=1, coords=coords, cutoff=cutoff_radius, gcn_max=12)\nagcn.reshape(-1, 1)\n\nwrite_xyz(\"output_test.xyz\", elements=elements, coords=coords, additional_data=additional_data)\n</code></pre>"},{"location":"CNA/","title":"Common Neighbour Analysis","text":"<p>The common neighbour analysis is a signature attributed to all pairs of nearest neighbour atoms in the system used to classify the geometrical environment of the atoms. For each pair of neighbours we evaluate a triplet of integers: (r, s, t) as:</p> rst <p>Number of shared neighbours of the pair, here the two green atoms share 4 neighbours (coloured in blue) so in this example the pair will have r = 4 </p> <p>Number of bonds between the r nieghbours (excluding pair), here you can see that there are two bonds between the 4 neighbours of the pair taken into consideration, so s = 1 </p> <p>Longest path along connected bonds between the r neighbours (excluding pair), here you can see that the two neighbours only form a path of length 1, so t = 1 </p>"},{"location":"CNA/#computing-the-pair-cna-signature","title":"Computing the pair CNA Signature","text":"<p>As said, the CNA signature is a pair property, in pySNOW we can compute the CNA for each pair of atom and obtain it as an \\(3\\cdot N_{pairs}\\) array where for each pair the subarray contains the (r, s, t) values, optionally the function will also return a list containing the indeces of the atoms forming each pair for which the CNA signature has been computed, this can be used (and is used by other fnctions which we will present below) to identify patterns in the observed CNA signatures.</p> <p>The method to compute the CNA involves, as always, as a first step, the reading of the coordinates of the atoms, then the function <code>calculate_cna(...)</code> can be used to obtain the desired output:</p> Using pySNOW ioUsing ASE ioUsing Ovito io <pre><code>from snow.lodispp.pp_io import read_xyz\nfrom snow.lodispp.cna import calculate_cna\n\nel, coords = read_xyz(\"Au976To.xyz\")\ncut_off = 4.079 * 0.85 # (1)\nn_pairs, cnas, pairs = calculate_cna(1, coords, cut_off, return_pair = True) # (2)\n</code></pre> <ol> <li>Cutoff as 0.85*lattice parameter</li> <li>The first 1 is the index_frame placeholder. Setting return_pair to True will return the indeces of the atoms forming each pair</li> </ol> <pre><code>from ase.io import read\nfrom snow.lodispp.cna import calculate_cna\n\nnano = read(\"Au976To.xyz\")\n\ncoords = nano.get_positions()\n\ncut_off = 4.079 * 0.85 # (1)\nn_pairs, cnas, pairs = calculate_cna(1, coords, cut_off, return_pair = True) # (2)\n</code></pre> <ol> <li>Cutoff as 0.85*lattice parameter</li> <li>The first 1 is the index_frame placeholder. Setting return_pair to True will return the indeces of the atoms forming each pair</li> </ol> <pre><code>from from ovito.io import import_file\n\nfrom snow.lodispp.cna import calculate_cna\n\npipeline = import_file(\"Au976To.xyz\")\n\ncoords = nano.get_positions()\n\ncut_off = 4.079 * 0.85 # (1)\nn_pairs, cnas, pairs = calculate_cna(1, coords, cut_off, return_pair = True) # (2)\n</code></pre> <ol> <li>Cutoff as 0.85*lattice parameter</li> <li>The first 1 is the index_frame placeholder. Setting return_pair to True will return the indeces of the atoms forming each pair</li> </ol> <p>Ovito users can also make use of our Ovito modifier CNAPatterner which provides a similar kind of analysis. While Ovito pipelines are generally tricky to deal with in python, using it is advisable when treating with larger systems and/or systems with periodic boundary conditions.</p>"},{"location":"GCN/","title":"GCN Computation","text":"<p>The GCN is an extended and generalized (as the name: Generalized Coordination Number implies) version of the Coordination Number (CN), it can be used to capture trends in adsorption nergy on surfaces and on nanoparticles.</p> <p>While the CN is just a count for each atom i the system of the number of other atoms that lie within a certain cutoff distance of the first atom itself, the GCN (or \\(\\bar{CN}\\)) is a weighted average of the CN of the atom neighbouring each atom in the system, that is:</p> \\[ \\bar{CN}(i) = \\sum_{j\\in nn}\\frac{CN(j)}{CN_{max}} \\] <p>where \\(CN_{max}\\) is the maximal CN for an atom in the bulk, for instance, in the case of fcc \\(CN_{max} = 12\\).</p>"},{"location":"GCN/#atop-gcn","title":"Atop GCN","text":"<p>The equation presented above is for the atop GCN, that is the GCN for an adsorption site corresponding to the atom itself, to compute such value in pySNOW we first need to load a structure from a coordinate file, here we will use the builtin function to read from an XYZ file, however any library that can read or generate coordinates for an atomic structure can be used to prepare the coordinate array required by the code.</p> agcn.py<pre><code>from snow.lodispp.pp_io import read_xyz\nfrom snow.descriptors.gcn import agcn_calculator\n\n# read a structure from an xyz file to a list of elements\n# and array of coordinates\nel, coords = read_xyz(\"Au561_Ih.xyz\")\n\n# impose a cutoff of 0.85 * lattice parameter, 4.079 Angstrom for gold\ncut_off = 4.079 * 0.85\n\n# compute the aGCN and save it as a 1d array\nagcn = agcn_calculator(1, coords, cut_off, gcn_max = 12.0) # (1)!\n</code></pre> <ol> <li>The first parameter is a placeholder for the frame number, this can be usefule to keep trak of the frame in a trajectory and potentially be used inlater version to automate anlysis of a trajectory </li> </ol> <p>Once the agcn for each atom has been computed the array can be saved as the extra column of an extended XYZ for visual representation using a software such as Ovito using the builtin function that allows users to write coordinates and any additional per-atom data to an XYZ file.</p> agcn.py<pre><code>from snow.lodispp.pp_io import write_xyz\n\nagcn.reshape(-1, 1) # (1)!\n\nwrite_xyz(\"Au561_Ih_aGCN.py\", el, coords, additional_data=agcn)\n</code></pre> <ol> <li>It is necessary to reshape the array into a column to save it to the xyz</li> </ol>"},{"location":"GCN/#bridge-gcn","title":"Bridge GCN","text":"<p>While the aGCN can be seen as an atomic descriptor, the GCN itself is, as mentioned in the beginning, a useful descriptor related to adsorption sites, and these can also be located between atoms. The simplest conceptually is the bridge site, located at the midpoint between a pair of atoms.</p> <p>The computation of the bGCN is similar to that of the aGCN, however here the average is over the CNs of the atoms that are neighbours of both atoms taken once, the weight, \\(CN_{max}\\) is in this case 18 for fcc.</p> <p>To ease visual representation the function for the computation of the bGCN allows for the optional output of the coordinates of the midpoints between the considered pairs of atoms, </p>"},{"location":"about/","title":"About","text":"<p>pySNOW, Software Nano Object Workflow, is written in the Python  programming language with the aim of providing a user frinedly integrated set of tools for the analysis of nanomaterials from atomistic simulations, it has been built by our team at the University of Milan with some design goals in mind:</p>"},{"location":"about/#ease-of-use","title":"Ease of use","text":"<p>pySNOW functiuons are mostly self explanaotry and relatively easy to use if the user knows a bit about what each descriptor implies, take for instance the function to compute the Steinhardt parameters:</p> <p>steinhardt.py<pre><code>stein = peratom_steinhardt(index_frame = 1, coords = coords, l = [4, 6], cut_off = 3.52)\n</code></pre> this function will produce a 2 (number of elements of l)x \\(n_{atoms}\\) array with for each atom (with coordinates in the coords array)the Steinhardt parameters of order 4 and 6, considering atoms as neighbours if they are within 3.52 Angstrom of each other.</p>"},{"location":"about/#independence","title":"Independence","text":"<p>While re-inventing the wheel goes against some of Python's founding principles, we wanted to keep pySNOW as independent as possible from external modules which might break down compatibility down the line. We still kept the widely used NumPy and SciPy libraries, without which things would have been quite the nightmare to implement in a clean efficient way, but part from these libraries and PyTest for automated testing, pySNOW can be run without any other dependency installed. </p>"},{"location":"about/#integrability","title":"Integrability","text":"<p>pySNOW contains some input functions for reading some type of files like XYZs and LAMMPS data files, however all functions in pySNOW only require as parameters atomic coordinates and  lists of elements, so that it is possible for users to use any type of functionality to read a structure and use the resulting coordinates as inputs.</p> <p>For instance one might want to use ASE rather than pySNOW to read an XYZ file, so that, to compute the Steinhardt parameters of order 4 and 6 as above:</p> using_ase.py<pre><code>from ase.io import read\nfrom snow.descriptors.steinhardt import peratom_steinhardt\n\nnano = read(\"Au_561Ih.xyz\")\n\nel = nano.get_chemical_symbols()\ncoords = nano.get_positions()\n\nstein = peratom_steinhardt(index_frame = 1, coords = coords, l = [4, 6], cut_off = 3.52)\n</code></pre> <p>rather than use the read_xyz function provided with pySNOW: only_snow.py<pre><code>from snow.lodispp.pp_io import read_xyz\nfrom snow.descriptors.steinhardt import peratom_steinhardt\n\nel, coords = read_xyz(\"Au_561Ih.xyz\")\n\nstein = peratom_steinhardt(index_frame = 1, coords = coords, l = [4, 6], cut_off = 3.52)\n</code></pre></p> <p>The advantage of using ASE (or other libraries) is that it supports multiple data files.</p>"},{"location":"install/","title":"Installing pySNOW","text":"<p>Installing pySNOW is (should be) quite easy.</p> <p>The first step (suggested) is to create a python environment for installation to avoid confilcts with previously installed libraries or different versions of required modules:</p> LinuxMacWindows <pre><code>python3 -m venv snowenv\nsource snowenv/bin/activate\n</code></pre> <pre><code>python3 -m venv snowenv\nsource snowenv/bin/activate\n</code></pre> <pre><code>python -m venv snowenv\n.\\snowenv\\Scripts\\activate\n</code></pre> <p>Note that pySNOW b default requires a version of python &gt;= 3.12, however users can optionally try to change this in the pyproject.toml file, this however has not been tried and might result in unwanted behaviour.</p> <p>After creating and activating the virtual environment you can clone the repository (or download the code as a zip and uncompressing it in any deisred location):</p> <pre><code>git clone https://github.com/nanoMLMS/pySNOW.git pysnow &amp;&amp; cd pysnow\n</code></pre> <p>From here you should be able to easily install the package by running: <pre><code>pip install .\n</code></pre></p> <p>Automated tests can be run using pytest with the following command: <pre><code>pytest .\n</code></pre> from the pysnow folder.</p> <p>Requirments for pYSNOW are NumPy and SciPy, which are automatically installed with pySNOW, additional optional dependencies are:</p> <ul> <li>tqdm for progress bars to check progress of long computations</li> </ul>"},{"location":"pddf_rdf/","title":"Distribution Functions","text":"<p>Distribution funtions are useful for identifying how atoms are ddistributed spatially, pySNOW allows for the computation of two such descriptors, the PDDF<sup>1</sup> and the RDF<sup>2</sup>, for both of these descriptors it is also possible to evaluate such descriptors globally for all atoms or a chemical distribution function, which will isolate distribution of atoms of the same chemical species.</p>"},{"location":"pddf_rdf/#pddf","title":"PDDF","text":"<p>The PDDF is computed as a binning of the distances between all pairs of atoms inside the system. Snow allows for the computation of the PPDF choosing either the number of bins or the size of the indivisual bins, the function itself has the following parameters_</p> <ul> <li>index_frame (integer): useful mostly for analysing trajectories and keeping track of the frame number, if dealing with a snapshot just assign it as 1</li> <li>coords (array): the array of coordinates of the atoms for the snapshot/ trajectory frame</li> <li>bin_precision (float): size of the individual bin in Angstrom</li> <li>bin_count (integer): the number of bins</li> </ul> <p>Note that only one of the final two parameters has to be specified, the other is computed automatically starting from the specified one and the size of the system:</p> \\[ l_{bin} = d_{max} / N_{bins} \\] <p>specifying both will favour bin_precision as it is the dirst to be considered in an if statement in the code.</p>"},{"location":"pddf_rdf/#usage-example","title":"Usage example","text":"<p>In this snippet we will compute the PDDF for a 561 atoms large cluster of gold atoms.</p> pddf.py<pre><code>from snow.lodispp.pp_io import read_xyz\nfrom snow.lodispp.utils import pddf_calculator\nimport matplotlib.pyplot as plt\n# read a structure from an xyz file to a list of elements\n# and array of coordinates\nel, coords = read_xyz(\"Au561_Ih.xyz\")\n</code></pre> <p>after reading the coordinates we compute the PDDF, the function has two returns: - The interatomic distance array with the equivalent distance for each bin - The number of pairs separated by an interatomic distance within each bin</p> <p>Here we use a bin_prescision of 0.5 Angstrom and then plot the distribution pddf.py linenums=<pre><code>dist, count = pddf_calculator(1, coords, bin_precision = 0.5)\n\nplt.plot(dist, count)\n</code></pre></p>"},{"location":"pddf_rdf/#pddf-by-element","title":"PDDF By Element","text":"<p>The study of nano alloys might require to know how atoms of a specific element contributing to the alloy are distributed, pySnow thus allow users to copmpute the PDDF restricted to a single element fo the alloy using the pddf_calculator_by_element function. This function has the same parameters as the general PDDF calculator save for a string field identified as element, moreover it requires users to pass the ordered list of elements as read from the coordinate files to the function.</p>"},{"location":"pddf_rdf/#example","title":"Example","text":"<p>In this example we shall study a gold-platinum alloy, we compute the partial PDDF for both gold and platinum and for the whole system then we plot it.</p> partial_pddf.py<pre><code>from snow.lodispp.pp_io import read_xyz\nfrom snow.lodispp.utils import pddf_calculator\nimport matplotlib.pyplot as plt\n# read a structure from an xyz file to a list of elements\n# and array of coordinates\nel, coords = read_xyz(\"AuPt559.xyz\")\n\ndist_au, count_au = pddf_calculator_by_element(1, coords, el, 'Au', 0.5)\ndist_pt, count_pt = pddf_calculator_by_element(1, coords, el, 'Pt', 0.5)\ndist, count = pddf_calculator(1, coords, bin_precision = 0.5)\n\nplt.plot(dist_au, count_au, label =\"PDDF Au\")\nplt.plot(dist_pt, count_pt, label =\"PDDF Pt\")\nplt.plot(dist, count, label =\"PDDF total\")\nplt.legend()\nplt.xaxis(\"d [Angs]\")\nplt.yaxis(\"Occurance\")\n</code></pre>"},{"location":"pddf_rdf/#rdf","title":"RDF","text":"<p>The RDF is a distribution</p> <ol> <li> <p>Pair Distance Distribution Function\u00a0\u21a9</p> </li> <li> <p>Radial Distribution Function\u00a0\u21a9</p> </li> </ol>"},{"location":"descriptors/gcn/","title":"Generalized Coordination Number","text":"<p>This module allows for the computation of the Generalized Coordination Number (GCN) for an atomic system.</p> <p>The GCN is a descriptor expanding on the better known Coordination Number (CN, the number of neighbours for each atom)</p>"},{"location":"descriptors/gcn/#functions","title":"Functions","text":"Source code in <code>snow/descriptors/gcn.py</code> <pre><code>def agcn_calculator(index_frame, coords, cut_off, dbulk : list[float], thr_cn: int, gcn_max = 12.0, strained: bool = False):\n    \"\"\"\n    \"\"\"\n    neigh_list, coord_numbers = coordination_number(index_frame, coords, cut_off, neigh_list=True)\n    n_atoms = len(coord_numbers)\n    agcn = np.zeros(n_atoms)\n    sites=[]\n\n    for i, atom_neighbors in enumerate(neigh_list):\n        if coord_numbers[i] &gt;= thr_cn:\n            continue\n        sites.append(coords[i])\n        if strained:\n            sgcn=0\n            for nb in neigh_list[i]:\n                for nnb in neigh_list[nb]:\n                    d_nb_nnb= np.linalg.norm(coords[nb] - coords[nnb])\n                    sgcn += dbulk/d_nb_nnb\n            self_sgcn=0\n            for nb in neigh_list[i]:\n                break\n                d_nb_nnb= np.linalg.norm(coords[nb] - coords[i])\n                self_sgcn += dbulk/d_nb_nnb\n            agcn[i]=((sgcn-self_sgcn)/gcn_max)\n        else:\n            agcn_i = sum(coord_numbers[neigh] for neigh in atom_neighbors)# - coord_numbers[i]\n            agcn[i]=(agcn_i / gcn_max)\n    return sites,agcn\n</code></pre>"},{"location":"lodispp/cna/","title":"Common Neighbour Analysis","text":"<p>pySNOW contains functions that allow users to compute CNA signature for each pair of nearest neighbours as well as identify to which signature each atom in the system partecipates to. The latter is especially useful in cathegorizing the atom based on its belonging to a particular geometrical structure, extending what done in Ovito, where atoms are only catheorized based on the local cristalline structure, allowing to identify atoms belonging  to a facet, an edge or a vertex.</p> <p>The CNA signature is a triplet of numbers (r, s, t) for each pair of neighbours where:</p> <ul> <li>r: number of common neighbours of the pair</li> <li>s: number of bonds between the r common neighbours</li> <li>t: the longest path that can be formed by joining the r neighbours that are neighbours of each other</li> </ul>"},{"location":"lodispp/cna/#functions","title":"Functions","text":"<p>The CNA calculator containes a series of functions for the comutation of the CAN signatures and patterns:</p>"},{"location":"lodispp/cna/#calculate-cna-fast","title":"Calculate CNA Fast","text":"<p>Faster version of calculate_cna that precomputes neighbor sets.</p>"},{"location":"lodispp/cna/#snow.lodispp.cna.calculate_cna_fast--parameters","title":"Parameters","text":"<p>index_frame : int     description coords : ndarray     3xNatoms array containing the coordinates of each atom cut_off : float     cutoff radius for the determination of nearest neighbors return_pair : bool, optional     Whether to return an ordered list of the indices of the atoms forming a given pair, by default False</p>"},{"location":"lodispp/cna/#snow.lodispp.cna.calculate_cna_fast--returns","title":"Returns","text":"<p>tuple[int, np.ndarray, list]     The number of pairs, the cna signatures [r, s, t] for each pair and the ordered list of pairs (if return_pair == True) tuple[int, np.ndarray]     The number of pairs, the cna signatures [r, s, t] for each pair</p> Source code in <code>snow/lodispp/cna.py</code> <pre><code>def calculate_cna_fast(index_frame, coords, cut_off = None, return_pair=False, pbc = False):\n    \"\"\"\n    Faster version of calculate_cna that precomputes neighbor sets.\n\n    Parameters\n    ----------\n    index_frame : int\n        _description_\n    coords : ndarray\n        3xNatoms array containing the coordinates of each atom\n    cut_off : float\n        cutoff radius for the determination of nearest neighbors\n    return_pair : bool, optional\n        Whether to return an ordered list of the indices of the atoms forming a given pair, by default False\n\n    Returns\n    -------\n    tuple[int, np.ndarray, list]\n        The number of pairs, the cna signatures [r, s, t] for each pair and the ordered list of pairs (if return_pair == True)\n    tuple[int, np.ndarray]\n        The number of pairs, the cna signatures [r, s, t] for each pair\n    \"\"\"\n    # Get neighbor list and pair list (assumed to be implemented efficiently)\n\n    if (cut_off == None):\n        r_i = np.zeros(len(coords))\n\n\n    neigh_list = nearest_neighbours(index_frame = index_frame, coords = coords, cut_off = cut_off, pbc=pbc)\n    pairs = pair_list(index_frame=index_frame, coords=coords, cut_off=cut_off, pbc = pbc)\n\n    # Precompute neighbor sets for fast membership tests\n    neigh_sets = [set(neigh) for neigh in neigh_list]\n\n    # Initialize result arrays\n    r = np.empty(len(pairs), dtype=int)\n    s = np.empty(len(pairs), dtype=float)\n    t = np.empty(len(pairs), dtype=float)\n    ret_pair = [] if return_pair else None\n\n\n\n    for i, p in enumerate(tqdm(pairs, desc=\"Processing pairs\")):\n        # Get neighbor sets for the two atoms in the pair\n        set1 = neigh_sets[p[0]]\n        set2 = neigh_sets[p[1]]\n        # Compute common neighbors using set intersection\n        common = set1 &amp; set2\n        r[i] = len(common)\n\n        # For s, sum the number of common neighbors between each neighbor in 'common'\n        # and the set 'common' itself, then divide by 2.\n        s_val = sum(len(neigh_sets[j] &amp; common) for j in common) / 2\n        s[i] = s_val\n\n        # Compute t using the existing function.\n        # If longest_path_or_cycle expects a numpy array, we convert common accordingly.\n        t[i] = longest_path_or_cycle(np.array(list(common)), neigh_list)\n\n        if return_pair:\n            ret_pair.append(p)\n\n    cna = np.column_stack((r, s, t))\n    if return_pair:\n        return len(pairs), cna, ret_pair\n    return len(pairs), cna\n</code></pre>"},{"location":"lodispp/cna/#write-cna-to-file","title":"Write CNA to file","text":"Source code in <code>snow/lodispp/cna.py</code> <pre><code>def write_cna(\n    frame,\n    len_pair,\n    cna,\n    pair_list,\n    file_path=None,\n    signature=True,\n    cna_unique=True\n):\n\n    if frame == 0 and os.path.exists(file_path + \"signatures.csv\"):\n        os.remove(file_path + \"signatures.csv\")\n\n    if frame == 0 and os.path.exists(file_path + \"cna_unique.csv\"):\n        os.remove(file_path + \"cna_unique.csv\")\n\n    perc = 100 * np.unique(cna, axis=0, return_counts=True)[1] / len_pair\n\n    if signature == True:\n\n        with open(file_path + \"signatures.csv\", \"a\") as f:\n            f.write(f\"\\n{frame}\\n\")\n\n            for i, p in enumerate(pair_list):\n                f.write(f\"{p[0]}, {p[1]}, {cna[i]}\\n\")\n\n    if pattern == True:\n        with open(file_path + \"pattern.csv\", \"a\") as f:\n            f.write(f\"\\n{frame}\\n\")\n\n            for i, p in enumerate(perc):\n                f.write(\n                    f\"{np.unique(cna, axis=0, return_counts=True)[0][i]}, {np.unique(cna, axis=0, return_counts=True)[1][i]},{p}\\n\"\n                )\n</code></pre>"},{"location":"lodispp/cna/#cna-patterns-per-atoms","title":"CNA Patterns per atoms","text":"<p>Optimized per-atom CNA calculation by precomputing a mapping from atom indices to pair indices. This avoids scanning the entire pair list for every atom.</p>"},{"location":"lodispp/cna/#snow.lodispp.cna.cna_peratom--parameters","title":"Parameters","text":"<p>index_frame : int     description coords : np.ndarray     Array containing the coordinates of each atom. cut_off : float     Cutoff radius for nearest-neighbor determination.</p>"},{"location":"lodispp/cna/#snow.lodispp.cna.cna_peratom--returns","title":"Returns","text":"<p>list of tuple[np.ndarray, np.ndarray]     For each atom, a tuple (unique_signatures, counts) representing the unique     CNA signatures from all pairs involving that atom and their respective counts.</p> Source code in <code>snow/lodispp/cna.py</code> <pre><code>def cna_peratom(index_frame: int, coords: np.ndarray, cut_off: float = None, pbc: bool = False):\n    \"\"\"\n    Optimized per-atom CNA calculation by precomputing a mapping from atom indices\n    to pair indices. This avoids scanning the entire pair list for every atom.\n\n    Parameters\n    ----------\n    index_frame : int\n        _description_\n    coords : np.ndarray\n        Array containing the coordinates of each atom.\n    cut_off : float\n        Cutoff radius for nearest-neighbor determination.\n\n    Returns\n    -------\n    list of tuple[np.ndarray, np.ndarray]\n        For each atom, a tuple (unique_signatures, counts) representing the unique\n        CNA signatures from all pairs involving that atom and their respective counts.\n    \"\"\"\n    # Compute CNA signatures and the corresponding pair list\n\n\n    _, cna, pair_list = calculate_cna_fast(\n        index_frame=index_frame, coords=coords, cut_off=cut_off, return_pair=True, pbc=pbc\n    )\n    num_atoms = len(coords)\n\n    # Precompute a mapping from each atom to the indices of pairs that involve it.\n    atom_to_pair = [[] for _ in range(num_atoms)]\n    for idx, (i, j) in enumerate(pair_list):\n        atom_to_pair[i].append(idx)\n        atom_to_pair[j].append(idx)\n\n    # Build the per-atom CNA information using the precomputed mapping.\n    cna_atom = []\n    for i in range(num_atoms):\n        pair_indices = atom_to_pair[i]\n        if pair_indices:\n            # Use NumPy advanced indexing to quickly select the relevant CNA rows.\n            cna_i = cna[pair_indices]\n            unique_signatures, counts = np.unique(cna_i, axis=0, return_counts=True)\n            cna_atom.append((unique_signatures, counts))\n        else:\n            # If no pairs include atom i, return empty arrays.\n            cna_atom.append((np.array([]), np.array([])))\n    return cna_atom\n</code></pre>"},{"location":"lodispp/cna/#cnap-index-per-atom","title":"CNAp Index per atom","text":"<p>Usage: <pre><code>cnap_peratom(index_frame: int, coords: np.ndarray, cut_off: float = None, pbc: bool = False) -&gt; np.ndarray\n</code></pre></p> <p>Computes the CNA Patterns for each atom in the system, assigning to each an integer which can be used to  identify the local structure, mapping integer-structure can be found in the README.</p>"},{"location":"lodispp/cna/#snow.lodispp.cna.cnap_peratom--parameters","title":"Parameters","text":"<p>index_frame : int     description coords : np.ndarray     3xNatoms array containing the coordainates of the atoms in the system cut_off : float     Cutoff radius for the determination of neighbours</p>"},{"location":"lodispp/cna/#snow.lodispp.cna.cnap_peratom--returns","title":"Returns","text":"<p>np.ndarray     1D array containing for each atom an integer identifing the structure (check the documentation)</p> Source code in <code>snow/lodispp/cna.py</code> <pre><code>def cnap_peratom(index_frame: int, coords: np.ndarray, cut_off: float = None, pbc: bool = False) -&gt; np.ndarray:\n    \"\"\"Computes the CNA Patterns for each atom in the system, assigning to each an integer which can be used to \n    identify the local structure, mapping integer-structure can be found in the README.\n\n\n    Parameters\n    ----------\n    index_frame : int\n        _description_\n    coords : np.ndarray\n        3xNatoms array containing the coordainates of the atoms in the system\n    cut_off : float\n        Cutoff radius for the determination of neighbours\n\n    Returns\n    -------\n    np.ndarray\n        1D array containing for each atom an integer identifing the structure (check the documentation)\n\n    \"\"\"\n    cna = cna_peratom(1, coords, cut_off, pbc=pbc)\n    cna_atom = np.zeros(len(coords))\n    count = 0\n    for i in tqdm(range(len(coords)), desc=\"Processing patterns\"):\n\n\n        n_sigs = len(\n            cna[i][1]\n        )  # number of unique signatures to which atom i partecipatr\n        sigs = cna[i][0]  # the unique signatures themselves\n        count = cna[i][1]  # the count of each signature\n        if n_sigs == 1 and count[0] == 12:\n            if (sigs[0] == [5, 5, 5]).all():\n                cna_atom[i] = 5\n            elif (sigs[0] == [4, 2, 1]).all():\n                cna_atom[i] = 4\n        elif n_sigs == 2:\n            if [4, 2, 2] in sigs and [5, 5, 5] in sigs:\n\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                idx_555 = np.where(np.all(sigs == [5, 5, 5], axis=1))[0]\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n                n_555 = count[idx_555][0] if count[idx_555].size &gt; 0 else 0\n\n                if n_422 == 10 and n_555 == 2:\n                    cna_atom[i] = 3\n            if [4, 2, 1] in sigs and [3, 1, 1] in sigs:\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n\n                if n_311 == 6 and n_421 == 3:\n                    cna_atom[i] = 15\n            if [2, 1, 1] in sigs and [4, 2, 1] in sigs:\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                idx_211 = np.where(np.all(sigs == [2, 1, 1], axis=1))[0]\n\n                if (\n                    idx_421.size &gt; 0 and idx_211.size &gt; 0\n                ):  # Ensure non-empty indices\n                    n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n                    n_211 = count[idx_211][0] if count[idx_211].size &gt; 0 else 0\n\n                    if n_211 == 4 and n_421 == 1:\n                        cna_atom[i] = 11\n                    elif n_211 == 4 and n_421 == 4:\n                        cna_atom[i] = 12\n            if [3, 2, 2] in sigs and [5, 5, 5] in sigs:\n                idx_322 = np.where(np.all(sigs == [3, 2, 2], axis=1))[0]\n                idx_555 = np.where(np.all(sigs == [5, 5, 5], axis=1))[0]\n                n_322 = count[idx_322][0] if count[idx_322].size &gt; 0 else 0\n                n_555 = count[idx_555][0] if count[idx_555].size &gt; 0 else 0\n\n                if n_322 == 5 and n_555 == 1:\n                    cna_atom[i] = 14\n            if [4, 2, 1] in sigs and [4, 2, 2] in sigs:\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n                n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n\n                if n_421 == 6 and n_422 == 6:\n                    cna_atom[i] = 16\n        elif n_sigs == 3:\n            if [1, 0, 0] in sigs and [2, 1, 1] in sigs and [4, 2, 2] in sigs:\n                idx_100 = np.where(np.all(sigs == [1, 0, 0], axis=1))[0]\n                idx_211 = np.where(np.all(sigs == [2, 1, 1], axis=1))[0]\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                n_100 = count[idx_100][0] if count[idx_100].size &gt; 0 else 0\n                n_211 = count[idx_211][0] if count[idx_211].size &gt; 0 else 0\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n\n                if n_100 == 2 and n_211 == 2 and n_422 == 2:\n                    cna_atom[i] = 6\n            if [2, 0, 0] in sigs and [3, 1, 1] in sigs and [4, 2, 1] in sigs:\n                idx_200 = np.where(np.all(sigs == [2, 0, 0], axis=1))[0]\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                n_200 = count[idx_200][0] if count[idx_200].size &gt; 0 else 0\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n\n                if n_200 == 2 and n_311 == 4 and n_421 == 1:\n                    cna_atom[i] = 8\n            if [2, 1, 1] in sigs and [3, 1, 1] in sigs and [4, 2, 1] in sigs:\n                idx_211 = np.where(np.all(sigs == [2, 1, 1], axis=1))[0]\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                n_211 = count[idx_211][0] if count[idx_211].size &gt; 0 else 0\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n\n                if n_211 == 3 and n_311 == 2 and n_421 == 2:\n                    cna_atom[i] = 10\n            if [3, 1, 1] in sigs and [3, 2, 2] in sigs and [4, 2, 2] in sigs:\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_322 = np.where(np.all(sigs == [3, 2, 2], axis=1))[0]\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_322 = count[idx_322][0] if count[idx_322].size &gt; 0 else 0\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n\n                if n_311 == 4 and n_322 == 2 and n_422 == 2:\n                    cna_atom[i] = 13\n        elif n_sigs == 4:\n\n            if (\n                [1, 0, 0] in sigs\n                and [2, 1, 1] in sigs\n                and [3, 2, 2] in sigs\n                and [4, 2, 2] in sigs\n            ):\n                idx_100 = np.where(np.all(sigs == [1, 0, 0], axis=1))[0]\n                idx_211 = np.where(np.all(sigs == [2, 1, 1], axis=1))[0]\n                idx_322 = np.where(np.all(sigs == [3, 2, 2], axis=1))[0]\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                n_100 = count[idx_100][0] if count[idx_100].size &gt; 0 else 0\n                n_211 = count[idx_211][0] if count[idx_211].size &gt; 0 else 0\n                n_322 = count[idx_322][0] if count[idx_322].size &gt; 0 else 0\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n\n                if n_100 == 1 and n_211 == 2 and n_322 == 1 and n_422 == 1:\n                    cna_atom[i] = 1\n\n            if (\n                [2, 0, 0] in sigs\n                and [2, 1, 1] in sigs\n                and [3, 1, 1] in sigs\n                and [4, 2, 1] in sigs\n            ):\n                idx_200 = np.where(np.all(sigs == [2, 0, 0], axis=1))[0]\n                idx_211 = np.where(np.all(sigs == [2, 1, 1], axis=1))[0]\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                n_200 = count[idx_200][0] if count[idx_200].size &gt; 0 else 0\n                n_211 = count[idx_211][0] if count[idx_211].size &gt; 0 else 0\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n\n                if n_200 == 1 and n_211 == 2 and n_311 == 2 and n_421 == 1:\n                    cna_atom[i] = 2\n\n            if (\n                [3, 0, 0] in sigs\n                and [3, 1, 1] in sigs\n                and [4, 2, 1] in sigs\n                and [4, 2, 2] in sigs\n            ):\n                idx_300 = np.where(np.all(sigs == [3, 0, 0], axis=1))[0]\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_421 = np.where(np.all(sigs == [4, 2, 1], axis=1))[0]\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                n_300 = count[idx_300][0] if count[idx_300].size &gt; 0 else 0\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_421 = count[idx_421][0] if count[idx_421].size &gt; 0 else 0\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n\n                if n_300 == 2 and n_311 == 4 and n_421 == 2 and n_422 == 2:\n                    cna_atom[i] = 9\n        elif n_sigs == 5:\n            if (\n                [2, 0, 0] in sigs\n                and [3, 0, 0] in sigs\n                and [3, 1, 1] in sigs\n                and [3, 2, 2] in sigs\n                and [4, 2, 2] in sigs\n            ):\n                idx_200 = np.where(np.all(sigs == [2, 0, 0], axis=1))[0]\n                idx_300 = np.where(np.all(sigs == [3, 0, 0], axis=1))[0]\n                idx_311 = np.where(np.all(sigs == [3, 1, 1], axis=1))[0]\n                idx_322 = np.where(np.all(sigs == [3, 2, 2], axis=1))[0]\n                idx_422 = np.where(np.all(sigs == [4, 2, 2], axis=1))[0]\n                n_200 = count[idx_200][0] if count[idx_200].size &gt; 0 else 0\n                n_300 = count[idx_300][0] if count[idx_300].size &gt; 0 else 0\n                n_311 = count[idx_311][0] if count[idx_311].size &gt; 0 else 0\n                n_322 = count[idx_322][0] if count[idx_322].size &gt; 0 else 0\n                n_422 = count[idx_422][0] if count[idx_422].size &gt; 0 else 0\n\n                if (\n                    n_200 == 2\n                    and n_300 == 1\n                    and n_311 == 2\n                    and n_322 == 1\n                    and n_422 == 1\n                ):\n                    cna_atom[i] = 7\n    return cna_atom\n</code></pre>"},{"location":"lodispp/physics/","title":"Physics","text":"<p>pySNOW can also compute pyzzik</p>"},{"location":"lodispp/pp_io/","title":"Generalized Coordination Number","text":"<p>This module allows for the computation of the Generalized Coordination Number (GCN) for an atomic system.</p> <p>The GCN is a descriptor expanding on the better known Coordination Number (CN, the number of neighbours for each atom)</p>"},{"location":"lodispp/pp_io/#functions","title":"Functions","text":""},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz","title":"<code>read_xyz(file_path)</code>","text":"<p>Reads the elements and coordinates of atoms from an xyz file at a given location</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz--parameters","title":"Parameters","text":"<p>file_path : str     Path to the xyz file with the structure</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz--returns","title":"Returns","text":"<p>Tuple[np.ndarray, np.ndarray]     Elements and coordinates array of the system</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz--raises","title":"Raises","text":"<p>FileNotFoundError     No file was found at the given location ValueError     Some error while reading the file Exception     Unexpected errors along the way</p> Source code in <code>snow/lodispp/pp_io.py</code> <pre><code>def read_xyz(file_path: str) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Reads the elements and coordinates of atoms from an xyz file at a given location\n\n    Parameters\n    ----------\n    file_path : str\n        Path to the xyz file with the structure\n\n    Returns\n    -------\n    Tuple[np.ndarray, np.ndarray]\n        Elements and coordinates array of the system\n\n    Raises\n    ------\n    FileNotFoundError\n        No file was found at the given location\n    ValueError\n        Some error while reading the file\n    Exception\n        Unexpected errors along the way\n    \"\"\"\n    try:\n        # Get the path of the calling script\n        caller_frame = inspect.stack()[1]  # Get the caller's frame\n        caller_script = caller_frame.filename  # Get the caller's script path\n\n        # Get the directory where the calling script is located\n        script_dir = os.path.dirname(os.path.realpath(caller_script))\n\n        # Construct the full path to the file\n        filepath = os.path.join(script_dir, file_path)\n\n        # Open the file\n        with open(filepath, \"r\") as xyz_file:\n            # Number of atoms\n            n_atoms = int(xyz_file.readline().strip())\n\n            # Skip the comment line\n            _ = xyz_file.readline().strip()\n\n            # Initialize containers\n            elements = []\n            coordinates = np.zeros((n_atoms, 3))\n\n            # Read the data\n            for i in range(n_atoms):\n                line = xyz_file.readline().split()\n                elements.append(line[0])  # Append element symbol\n                coordinates[i, :] = list(map(float, line[1:4]))  # Convert coordinates to float\n\n        return elements, coordinates\n\n    except FileNotFoundError:\n        raise FileNotFoundError(f\"The file '{file_path}' does not exist.\")\n    except ValueError as e:\n        raise ValueError(f\"Error reading '{file_path}': {e}\")\n    except Exception as e:\n        raise Exception(f\"An unexpected error occurred: {e}\")\n</code></pre>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz_movie","title":"<code>read_xyz_movie(file_path)</code>","text":"<p>Obtains the coordinates and elements for each frame of an xyz trajectory (for now it only supports trajectories where the number of atoms and chemical composition is fixed through the whole trajectory).</p> <p>Note that it only creates a singe array for the elements rather than a per-frame array.</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz_movie--parameters","title":"Parameters","text":"<p>file_path : str     Path to the xyz file with the structure</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.read_xyz_movie--returns","title":"Returns","text":"<p>Tuple[np.ndarray, np.ndarray]     Elements array and a (n_frames x 3 x n_atoms) array for the coordinates</p> Source code in <code>snow/lodispp/pp_io.py</code> <pre><code>def read_xyz_movie(file_path: str) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"Obtains the coordinates and elements for each frame of an xyz trajectory (for now it only supports trajectories\n    where the number of atoms and chemical composition is fixed through the whole trajectory).\n\n    Note that it only creates a singe array for the elements rather than a per-frame array.\n\n    Parameters\n    ----------\n    file_path : str\n        Path to the xyz file with the structure\n\n\n    Returns\n    -------\n    Tuple[np.ndarray, np.ndarray]\n        Elements array and a (n_frames x 3 x n_atoms) array for the coordinates\n    \"\"\"\n\n\n    with open(file_path, \"r\") as xyz_file:\n        # Read the total number of atoms from the first line\n        n_atoms = int(xyz_file.readline().strip())\n\n    # Calculate the number of frames in the file\n    num_lines = sum(1 for _ in open(file_path))\n    n_frames = num_lines // (n_atoms + 2)\n\n    # Initialize arrays\n    coords = np.zeros((n_frames, n_atoms, 3))\n    elements = []\n\n    # Parse the file to extract data\n    with open(file_path, \"r\") as xyz_file:\n        for frame in range(n_frames):\n            _ = xyz_file.readline().strip()  # Skip atom count line\n            _ = xyz_file.readline().strip()  # Skip comment line\n\n            for atom in range(n_atoms):\n                line = xyz_file.readline().split()\n                if frame == 0:  # Store elements only once\n                    elements.append(line[0])\n                coords[frame, atom, :] = list(map(float, line[1:4]))\n\n    return elements, coords\n</code></pre>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.write_movie_xyz","title":"<code>write_movie_xyz(frame, filename, elements, coords, additional_data=None)</code>","text":"<p>Writes atomic data to an XYZ file in OVITO-compatible format.</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.write_movie_xyz--parameters","title":"Parameters","text":"<p>frame: int     Frame number. filename: str     Name of the output .xyz file. elements: ndarray     List of atomic symbols (e.g., ['Au', 'Au', ...]). coords: ndarray)     Nx3 array of atomic coordinates. additional_data: list or np.ndarray, optional     Additional per-atom data, such as coordination numbers.</p> <p>Returns:</p> Type Description <p>An xyz file containing the elements and coordinates of each atom and any additional per atom data (e.g. coordination number, agcn, strain...)</p> Source code in <code>snow/lodispp/pp_io.py</code> <pre><code>def write_movie_xyz(frame, filename, elements, coords, additional_data=None):\n    \"\"\"\n    Writes atomic data to an XYZ file in OVITO-compatible format.\n\n    Parameters\n    ----------\n    frame: int\n        Frame number.\n    filename: str\n        Name of the output .xyz file.\n    elements: ndarray\n        List of atomic symbols (e.g., ['Au', 'Au', ...]).\n    coords: ndarray)\n        Nx3 array of atomic coordinates.\n    additional_data: list or np.ndarray, optional\n        Additional per-atom data, such as coordination numbers.\n\n    Returns:\n        An xyz file containing the elements and coordinates of each atom and any additional per atom data (e.g. coordination number, agcn, strain...)\n    \"\"\"\n\n    if frame==0 and os.path.exists(filename):\n            os.remove(filename)\n\n    n_atoms = len(coords)\n\n    # Check if additional_data is provided and has the correct shape\n    if additional_data is not None:\n        additional_data = np.array(additional_data)\n        if additional_data.shape[0] != n_atoms:\n            raise ValueError(\n                f\"The number of rows in additional_data ({additional_data.shape[0]}) must match the number of atoms ({n_atoms}).\")\n\n    with open(filename, 'a') as xyz_file:\n        # Write header\n        xyz_file.write(f\"{n_atoms}\\n\\n\")\n        #xyz_file.write(f\"\\n{frame}\\n\")\n        #xyz_file.write(\"Generated XYZ file with optional properties\\n\")\n\n        # Write atom data\n        for i in range(n_atoms):\n            atom_line = f\"{elements[i]} {coords[i, 0]:.6f} {coords[i, 1]:.6f} {coords[i, 2]:.6f}\"\n            if additional_data is not None:\n                # Add the additional per-atom data\n                atom_line += ' ' + ' '.join([f\"{additional_data[i, j]:.6f}\" for j in range(additional_data.shape[1])])\n            xyz_file.write(atom_line + \"\\n\")\n</code></pre>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.write_xyz","title":"<code>write_xyz(filename, elements, coords, additional_data=None)</code>","text":"<p>Writes atomic data to an XYZ file in OVITO-compatible format.</p>"},{"location":"lodispp/pp_io/#snow.lodispp.pp_io.write_xyz--parameters","title":"Parameters","text":"<p>filename: str     Name of the output .xyz file. elements: ndarray     List of atomic symbols (e.g., ['Au', 'Au', ...]). coords: ndarray)     Nx3 array of atomic coordinates. additional_data: list or np.ndarray, optional     Additional per-atom data, such as coordination numbers.</p> <p>Returns:</p> Type Description <p>An xyz file containing the elements and coordinates of each atom and any additional per atom data (e.g. coordination number, agcn, strain...)</p> Source code in <code>snow/lodispp/pp_io.py</code> <pre><code>def write_xyz(filename, elements, coords, additional_data=None):\n    \"\"\"\n    Writes atomic data to an XYZ file in OVITO-compatible format.\n\n    Parameters\n    ----------\n    filename: str\n        Name of the output .xyz file.\n    elements: ndarray\n        List of atomic symbols (e.g., ['Au', 'Au', ...]).\n    coords: ndarray)\n        Nx3 array of atomic coordinates.\n    additional_data: list or np.ndarray, optional\n        Additional per-atom data, such as coordination numbers.\n\n    Returns:\n        An xyz file containing the elements and coordinates of each atom and any additional per atom data (e.g. coordination number, agcn, strain...) \n    \"\"\"\n    n_atoms = len(elements)\n\n    # Check if additional_data is provided and has the correct shape\n    if additional_data is not None:\n        additional_data = np.array(additional_data)\n        if additional_data.shape[0] != n_atoms:\n            raise ValueError(f\"The number of rows in additional_data ({additional_data.shape[0]}) must match the number of atoms ({n_atoms}).\")\n\n    with open(filename, 'w') as xyz_file:\n        # Write header\n        xyz_file.write(f\"{n_atoms}\\n\")\n        xyz_file.write(\"Generated XYZ file with optional properties\\n\")\n\n        # Write atom data\n        for i in range(n_atoms):\n            atom_line = f\"{elements[i]} {coords[i, 0]:.6f} {coords[i, 1]:.6f} {coords[i, 2]:.6f}\"\n            if additional_data is not None:\n\n                # Add the additional per-atom data\n                atom_line += ' ' + ' '.join([f\"{additional_data[i, j]:.6f}\" for j in range(additional_data.shape[1])])\n            xyz_file.write(atom_line + \"\\n\")\n</code></pre>"},{"location":"lodispp/utils/","title":"Generalized Coordination Number","text":"<p>This module allows for the computation of the Generalized Coordination Number (GCN) for an atomic system.</p> <p>The GCN is a descriptor expanding on the better known Coordination Number (CN, the number of neighbours for each atom)</p>"},{"location":"lodispp/utils/#functions","title":"Functions","text":""},{"location":"lodispp/utils/#snow.lodispp.utils.adjacency_matrix","title":"<code>adjacency_matrix(index_frame, coords, cutoff)</code>","text":"<p>Computes the adjacency matrix Ad_ij, where the entry ij is 1 if distance r_ij&lt;=cutoff, else is 0</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def adjacency_matrix(index_frame, coords, cutoff):\n    \"\"\"\n    Computes the adjacency matrix Ad_ij, where the entry ij is 1 if distance r_ij&lt;=cutoff, else is 0\n    \"\"\"\n    dist_mat = distance_matrix(index_frame, coords)[0]\n    adj_matrix = dist_mat &lt;= cutoff\n    return adj_matrix\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.apply_pbc","title":"<code>apply_pbc(coords, box_size)</code>","text":"<p>Apply periodic boundary conditions to atom coordinates. Maps coordinates to be within the simulation box.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.apply_pbc--parameters","title":"Parameters","text":"<p>coords : np.ndarray     Atom coordinates array, shape (n_atoms, 3). box_size : np.ndarray     Box size array (3,) or (3,2) depending on box format.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.apply_pbc--returns","title":"Returns","text":"<p>np.ndarray     Coordinates after applying PBC.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def apply_pbc(coords, box_size):\n\n    \"\"\"\n    Apply periodic boundary conditions to atom coordinates.\n    Maps coordinates to be within the simulation box.\n\n    Parameters\n    ----------\n    coords : np.ndarray\n        Atom coordinates array, shape (n_atoms, 3).\n    box_size : np.ndarray\n        Box size array (3,) or (3,2) depending on box format.\n\n    Returns\n    -------\n    np.ndarray\n        Coordinates after applying PBC.\n    \"\"\"\n    if box_size.shape == (3, 2):  # Lower and upper bounds provided\n        lower_bounds = box_size[:, 0]\n        upper_bounds = box_size[:, 1]\n        # Apply modulo to map the coordinates back into the box\n        coords = np.mod(coords - lower_bounds, upper_bounds - lower_bounds) + lower_bounds\n    elif box_size.shape == (3,):  # Direct box lengths\n        coords = np.mod(coords, box_size)\n    else:\n        raise ValueError(\"Box size must be of shape (3,) or (3,2)\")\n\n    return coords\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.bounding_box","title":"<code>bounding_box(points)</code>","text":"<p>Calculate an axis-aligned bounding box from a set of points.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def bounding_box(points):\n    \"\"\"Calculate an axis-aligned bounding box from a set of points.\"\"\"\n    x_coordinates, y_coordinates, z_coordinates = zip(*points)\n    return np.array([\n        [min(x_coordinates), max(x_coordinates)],\n        [min(y_coordinates), max(y_coordinates)],\n        [min(z_coordinates), max(z_coordinates)],\n    ])\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.center_of_mass","title":"<code>center_of_mass(index_frame, coords, elements)</code>","text":"<p>Calculate the center of mass for a given frame of coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>index_frame</code> <code>int</code> <p>Index of the frame in the trajectory.</p> required <code>coords</code> <code>ndarray</code> <p>Array of atomic coordinates of shape (frames, atoms, 3).</p> required <code>elements</code> <code>list or ndarray</code> <p>List of element symbols corresponding to the atoms.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The center of mass as a 3D vector.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def center_of_mass(index_frame: int, coords: np.ndarray, elements) -&gt; np.ndarray:\n    \"\"\"\n    Calculate the center of mass for a given frame of coordinates.\n\n    Parameters:\n        index_frame (int): Index of the frame in the trajectory.\n        coords (np.ndarray): Array of atomic coordinates of shape (frames, atoms, 3).\n        elements (list or np.ndarray): List of element symbols corresponding to the atoms.\n\n    Returns:\n        np.ndarray: The center of mass as a 3D vector.\n    \"\"\"\n\n\n    # Get the masses of the elements\n    masses = np.array([mass[e] for e in elements])\n\n    # Compute the total mass\n    total_mass = np.sum(masses)\n\n    # Calculate the weighted average of coordinates\n    com = np.sum(coords * masses[:, None  ], axis=0) / total_mass\n\n    return com\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.chemical_pddf_calculator","title":"<code>chemical_pddf_calculator(index_frame, coords, elements, bin_precision=None, bin_count=None)</code>","text":"<p>Computes the pair distance distribution function for a given set of coordinates of atoms. </p> <p>The user can either provide a bin precision or the numer of bins depending on wheter they are striving for a specific precision in the bins or on a specific number of bins for representation.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.chemical_pddf_calculator--parameters","title":"Parameters","text":"<p>index_frame : int     Index of the frame relative to the snapshot, primarily for reference. coords : ndarray     Array of the coordinates of the atoms forming the system. elements: ndarray     Array of elements bin_precision: float, optional     Specify a value if you want to compute the PDDF with a given bin precision (in Angstrom) bin_count: int, optional     Specify a value if you want to compute the PDDF with a given number of bins</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.chemical_pddf_calculator--returns","title":"Returns","text":"<p>tuple     - ndarray: the values of the interatomic distances for each bin     - ndarray: the number of atoms within a given distance for each bin</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def chemical_pddf_calculator(index_frame, coords, elements, bin_precision=None, bin_count=None):\n    \"\"\"\n    Computes the pair distance distribution function for a given set of coordinates of atoms. \\n\n    The user can either provide a bin precision or the numer of bins depending on wheter they are striving for a specific precision in the bins\n    or on a specific number of bins for representation.\n\n    Parameters\n    ----------\n    index_frame : int\n        Index of the frame relative to the snapshot, primarily for reference.\n    coords : ndarray\n        Array of the coordinates of the atoms forming the system.\n    elements: ndarray\n        Array of elements\n    bin_precision: float, optional\n        Specify a value if you want to compute the PDDF with a given bin precision (in Angstrom)\n    bin_count: int, optional\n        Specify a value if you want to compute the PDDF with a given number of bins\n\n    Returns\n    -------\n    tuple\n        - ndarray: the values of the interatomic distances for each bin\n        - ndarray: the number of atoms within a given distance for each bin\n\n    \"\"\"\n    unique_elements, n_elements = np.unique(elements, return_counts=True)\n\n    pddf_dict = {}\n    elements = np.array(elements)\n    if bin_count:\n        d_tot, pddf_tot = pddf_calculator(index_frame=index_frame, coords=coords, bin_count=bin_count)\n    elif bin_precision:\n        d_tot, pddf_tot = pddf_calculator(index_frame=index_frame, coords=coords, bin_precision=bin_precision)\n\n    pddf_dict[\"Tot\"] = [d_tot, pddf_tot]\n    for el in unique_elements:\n\n        idx_el = np.where(elements == str(el))[0]\n        coords_el = np.array(coords[idx_el])\n\n        if bin_count:\n            d_el, pddf_el = pddf_calculator(index_frame=index_frame, coords=coords_el, bin_count=bin_count)\n        elif bin_precision:\n            d_el, pddf_el = pddf_calculator(index_frame=index_frame, coords=coords_el, bin_precision=bin_precision)\n        else:\n            raise ValueError(\"Either bin_count or bin_precision must be provided.\")\n\n        pddf_dict[el] = [d_el, pddf_el]    \n\n    return pddf_dict\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.coordination_number","title":"<code>coordination_number(index_frame, coords, cut_off, neigh_list=False)</code>","text":"<p>Computes the coordination number (number of nearest neighbours within a cutoff) for each atom in the system, optionally it also returns the neighbour list</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.coordination_number--parameters","title":"Parameters","text":"<p>index_frame : int     Index of the frame relative to the snapshot, primarily for reference. coords : ndarray     Array of the coordinates of the atoms forming the system. cut_off : float     The cutoff distance for determining nearest neighbors. neigh_list : bool, optional     Option to return the neighbour list as well as the coordination number of each atom (defualt is False)</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.coordination_number--returns","title":"Returns","text":"<p>If neigh_list is True:     tuple         - list: neighbour list, the list of indeces of the neighbours of each atom         - ndarray: the coordination numbers of each atom Otherwise:     - ndarray: the coordination numbers of each atom</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def coordination_number(index_frame, coords, cut_off, neigh_list = False):\n    \"\"\"\n    Computes the coordination number (number of nearest neighbours within a cutoff) for each atom in the system,\n    optionally it also returns the neighbour list\n\n    Parameters\n    ----------\n    index_frame : int\n        Index of the frame relative to the snapshot, primarily for reference.\n    coords : ndarray\n        Array of the coordinates of the atoms forming the system.\n    cut_off : float\n        The cutoff distance for determining nearest neighbors.\n    neigh_list : bool, optional\n        Option to return the neighbour list as well as the coordination number of each atom (defualt is False)\n\n    Returns\n    -------\n    If neigh_list is True:\n        tuple\n            - list: neighbour list, the list of indeces of the neighbours of each atom\n            - ndarray: the coordination numbers of each atom\n    Otherwise:\n        - ndarray: the coordination numbers of each atom\n    \"\"\"\n    neigh = nearest_neighbours(index_frame=index_frame, coords=coords, cut_off=cut_off)\n    n_atoms = np.shape(coords)[0]\n    coord_numb = np.zeros(n_atoms)\n    for i in range(n_atoms):\n        coord_numb[i] = len(neigh[i])\n    if neigh_list:\n        return neigh, coord_numb\n    else:\n        return coord_numb\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.distance_matrix","title":"<code>distance_matrix(index_frame, coords)</code>","text":"<p>Computes distance between atoms and saves them in a matrix of distances</p> <p>Parameters:</p> Name Type Description Default <code>index_frame</code> <code>int</code> <p>index of the current frame if it is a movie, mostrly for reference</p> required <code>coords</code> <code>array</code> <p>array of the 3d coordinates</p> required <p>Returns:</p> Name Type Description <code>dist_mat</code> <code>array</code> <p>distance matrix</p> <code>dist_max</code> <code>float</code> <p>the maximum distance between atoms</p> <code>dist_min</code> <code>float</code> <p>the minimum distance between atoms</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def distance_matrix(index_frame, coords):\n    \"\"\"\n    Computes distance between atoms and saves them in a matrix of distances\n\n    Parameters:\n        index_frame (int): index of the current frame if it is a movie, mostrly for reference\n        coords (array): array of the 3d coordinates\n\n    Returns:\n        dist_mat (array): distance matrix\n\n        dist_max (float): the maximum distance between atoms\n        dist_min (float): the minimum distance between atoms\n    \"\"\"\n    distances = pdist(coords)\n    dist_mat = squareform(distances)\n    dist_min = 0.0\n    dist_max = np.max(dist_mat)\n    return dist_mat, dist_max, dist_min\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_distance_matrix","title":"<code>hetero_distance_matrix(index_frame, coords, elements)</code>","text":"<p>summary</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_distance_matrix--parameters","title":"Parameters","text":"<p>index_frame : type description coords : type description elements : type description</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_distance_matrix--returns","title":"Returns","text":"<p>type description</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def hetero_distance_matrix(index_frame, coords, elements):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    index_frame : _type_\n        _description_\n    coords : _type_\n        _description_\n    elements : _type_\n        _description_\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n    n_atoms = np.shape(coords)[0]\n    dist_mat, dist_max, dist_min = distance_matrix(\n        index_frame=index_frame, coords=coords\n    )\n\n    triu_indices = np.triu_indices(n_atoms, k=1)\n    id_i, id_j = triu_indices\n\n    for i in range(len(id_i)):\n        id_is, id_js = id_i[i], id_j[i]\n\n        if elements[id_is] == elements[id_js]:\n            dist_mat[id_is, id_js] = 0\n            dist_mat[id_js, id_is] = 0  # Ensure symmetry\n\n    return dist_mat\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_pddf_calculator","title":"<code>hetero_pddf_calculator(index_frame, coords, elements, bin_precision=None, bin_count=None)</code>","text":"<p>summary</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_pddf_calculator--parameters","title":"Parameters","text":"<p>index_frame : type description coords : type description elements : type description bin_precision : type, optional     description, by default None bin_count : type, optional     description, by default None</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_pddf_calculator--returns","title":"Returns","text":"<p>type description</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.hetero_pddf_calculator--raises","title":"Raises","text":"<p>ValueError     description ValueError     description</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def hetero_pddf_calculator(index_frame, coords, elements, bin_precision=None, bin_count=None):\n    \"\"\"_summary_\n\n    Parameters\n    ----------\n    index_frame : _type_\n        _description_\n    coords : _type_\n        _description_\n    elements : _type_\n        _description_\n    bin_precision : _type_, optional\n        _description_, by default None\n    bin_count : _type_, optional\n        _description_, by default None\n\n    Returns\n    -------\n    _type_\n        _description_\n\n    Raises\n    ------\n    ValueError\n        _description_\n    ValueError\n        _description_\n    \"\"\"\n    n_atoms = np.shape(coords)[0]\n    dist_mat = hetero_distance_matrix(index_frame=index_frame, elements=elements, coords=coords)\n\n    triu_indices = np.triu_indices(n_atoms, k=1)\n    distances = dist_mat[triu_indices]\n\n    # Exclude zero distances\n    distances = distances[distances &gt; 0]\n\n    if distances.size == 0:\n        raise ValueError(\"No valid nonzero distances found. Check your input data.\")\n\n    dist_max = np.max(distances)\n\n    if bin_precision:\n        n_bins = int(np.ceil(dist_max / bin_precision))\n    elif bin_count:\n        n_bins = bin_count\n        bin_precision = dist_max / n_bins\n    else:\n        raise ValueError(\"You must specify either bin_precision or bin_count.\")\n\n    bins = np.linspace(0, dist_max, n_bins + 1)\n    dist_count, _ = np.histogram(distances, bins=bins)\n\n    return bins[:-1] + bin_precision / 2, dist_count\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.nearest_neighbours","title":"<code>nearest_neighbours(index_frame, coords, cut_off=None, pbc=False, box=None)</code>","text":"<p>Computes nearest neighbors for each atom, considering periodic boundary conditions (PBC) if requested.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.nearest_neighbours--parameters","title":"Parameters","text":"<p>index_frame : int     Number of the frame if a movie. coords : ndarray     XYZ coordinates of atoms, shape (n_atoms, 3). cut_off : float, optional     Cutoff distance for finding neighbors (in \u00c5). If None, an adaptive cutoff is used. pbc : bool, optional     Whether to apply periodic boundary conditions (default: False). box : ndarray, optional     Simulation box size in the form (3,) for orthorhombic boxes or (3,2) for lower and upper bounds.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.nearest_neighbours--returns","title":"Returns","text":"<p>list of lists     Each sublist contains the indices of neighboring atoms for the corresponding atom.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def nearest_neighbours(index_frame: int, coords: np.ndarray, cut_off: float = None, pbc: bool = False, box: np.ndarray = None) -&gt; list:\n    \"\"\"\n    Computes nearest neighbors for each atom, considering periodic boundary conditions (PBC) if requested.\n\n    Parameters\n    ----------\n    index_frame : int\n        Number of the frame if a movie.\n    coords : ndarray\n        XYZ coordinates of atoms, shape (n_atoms, 3).\n    cut_off : float, optional\n        Cutoff distance for finding neighbors (in \u00c5). If None, an adaptive cutoff is used.\n    pbc : bool, optional\n        Whether to apply periodic boundary conditions (default: False).\n    box : ndarray, optional\n        Simulation box size in the form (3,) for orthorhombic boxes or (3,2) for lower and upper bounds.\n\n    Returns\n    -------\n    list of lists\n        Each sublist contains the indices of neighboring atoms for the corresponding atom.\n    \"\"\"\n    sqrt_2 = np.sqrt(2)\n\n    if pbc:\n        if box is None:\n            raise ValueError(\"Box must be provided if PBC is enabled.\")\n\n        # Ensure box is correctly formatted\n        if box.shape == (3, 2):  # Lower and upper bounds provided\n            box_size = box[:, 1] - box[:, 0]\n        elif box.shape == (3,):  # Direct box lengths\n            box_size = box\n        else:\n            raise ValueError(\"Box must be of shape (3,) or (3,2)\")\n\n        # Create KD-tree with periodic boundaries\n        neigh_tree = cKDTree(coords, boxsize=box_size)\n    else:\n        # Standard KD-tree without PBC\n        neigh_tree = cKDTree(coords)\n\n    r_cut = np.full(len(coords), cut_off if cut_off is not None else 0.0)\n\n    if cut_off is None:\n        # Compute an adaptive cutoff\n        for i, atom in enumerate(coords):\n            d, _ = neigh_tree.query(atom, k=12)  # 12 nearest neighbors\n            d_avg = np.mean(d)\n            r_cut[i] = rescale * d_avg  # Adaptive cutoff\n\n    # Find neighbors within cutoff\n    neigh = []\n    for i, atom in enumerate(coords):\n        neighbors = neigh_tree.query_ball_point(atom, r_cut[i])  # Find points within radius\n        neigh.append([n for n in neighbors if n != i])  # Remove self\n\n    return neigh\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.pair_list","title":"<code>pair_list(index_frame, coords, cut_off=None, pbc=False, box=None)</code>","text":"<p>Generates a list of all pairs of atoms within a certain adaptive cutoff distance of each other.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.pair_list--parameters","title":"Parameters","text":"<p>index_frame : int     Index of the frame if a movie (not used in the current version but can be useful for dynamic systems). coords : np.ndarray     Array with the XYZ coordinates of the atoms, shape (n_atoms, 3). cut_off : float, optional     Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom. pbc : bool, optional     Whether to apply periodic boundary conditions. Defaults to False. box : np.ndarray, optional     Simulation box size (either [Lx, Ly, Lz] or [[xmin, xmax], [ymin, ymax], [zmin, zmax]]).</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.pair_list--returns","title":"Returns","text":"<p>list     List of tuples representing pairs of atoms that are within the cutoff distance.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def pair_list(index_frame: int, coords: np.ndarray, cut_off: float = None, pbc: bool = False, box: np.ndarray = None) -&gt; list:\n    \"\"\"\n    Generates a list of all pairs of atoms within a certain adaptive cutoff distance of each other.\n\n    Parameters\n    ----------\n    index_frame : int\n        Index of the frame if a movie (not used in the current version but can be useful for dynamic systems).\n    coords : np.ndarray\n        Array with the XYZ coordinates of the atoms, shape (n_atoms, 3).\n    cut_off : float, optional\n        Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom.\n    pbc : bool, optional\n        Whether to apply periodic boundary conditions. Defaults to False.\n    box : np.ndarray, optional\n        Simulation box size (either [Lx, Ly, Lz] or [[xmin, xmax], [ymin, ymax], [zmin, zmax]]).\n\n    Returns\n    -------\n    list\n        List of tuples representing pairs of atoms that are within the cutoff distance.\n    \"\"\"\n    sqrt_2 = np.sqrt(2)\n\n    if pbc:\n        if box is None:\n            raise ValueError(\"Box must be provided if PBC is enabled.\")\n\n        # Ensure box is correctly formatted\n        if box.shape == (3, 2):  # Lower and upper bounds provided\n            box_size = box[:, 1] - box[:, 0]\n        elif box.shape == (3,):  # Direct box lengths\n            box_size = box\n        else:\n            raise ValueError(\"Box must be of shape (3,) or (3,2)\")\n\n        # Create KD-tree with periodic boundaries\n        neigh_tree = cKDTree(coords, boxsize=box_size)\n    else:\n        # Standard KD-tree without PBC\n        neigh_tree = cKDTree(coords)\n\n    # Compute an adaptive cutoff for each atom if not provided\n    r_cut = np.full(len(coords), cut_off if cut_off is not None else 0.0)\n\n    if cut_off is None:\n        for i, atom in enumerate(coords):\n            d, _ = neigh_tree.query(atom, k=12)  # 12 nearest neighbors\n            d_avg = np.mean(d)\n            r_cut[i] = rescale * d_avg  # Adaptive cutoff per atom\n\n    # Find atom pairs within adaptive cutoffs\n    pairs = set()\n    for i, atom in enumerate(coords):\n        neighbors = neigh_tree.query_ball_point(atom, r_cut[i])\n        for j in neighbors:\n            if i &lt; j:  # Avoid duplicates (ensures (i, j) but not (j, i))\n                pairs.add((i, j))\n\n    return list(pairs)\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.partial_rdf_calculator","title":"<code>partial_rdf_calculator(index_frame, elements, coords, cut_off, bin_count=None, bin_precision=None)</code>","text":"<p>Computes the radial distribution function for the system computing both the total and elemnt separated function, that is, if there are two atomic species (say Au and Pd) it computes the Au-Au, Pd-Pd and \"chemical blind\" RDF.</p> <p>To bin the distribution the user can decide wether they want to specify the bin precision (in Angstrom) or the number of bins. One of  the two has to be chosen.</p> <p>To facilitate the representation and use, the cmputed RDF is returned as a dictionary. </p>"},{"location":"lodispp/utils/#snow.lodispp.utils.partial_rdf_calculator--parameters","title":"Parameters","text":"<p>index_frame : int     description elements : np.ndarray     description coords : np.ndarray     XYZ coordinates of atoms, shape (n_atoms, 3). cut_off : float     Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom. bin_count : int, optional     Number of bins, by default None bin_precision : float, optional     Bin precision, by default None</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.partial_rdf_calculator--returns","title":"Returns","text":"<p>dict     Dictionary containing as keys the element for which the rdf has been computed and as value two arrays, one continaing the bineed distance     the other containg the computed RDF.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.partial_rdf_calculator--raises","title":"Raises","text":"<p>ValueError     Raised if the user does not specify either the bin_count or the bin_precision.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def partial_rdf_calculator(\n    index_frame: int,\n    elements: np.ndarray,\n    coords: np.ndarray,\n    cut_off: int,\n    bin_count: int = None,\n    bin_precision: float = None\n) -&gt; dict:\n    \"\"\"Computes the radial distribution function for the system computing both the total and elemnt separated function, that is,\n    if there are two atomic species (say Au and Pd) it computes the Au-Au, Pd-Pd and \"chemical blind\" RDF.\n\n    To bin the distribution the user can decide wether they want to specify the bin precision (in Angstrom) or the number of bins. One of \n    the two has to be chosen.\n\n    To facilitate the representation and use, the cmputed RDF is returned as a dictionary. \n\n    Parameters\n    ----------\n    index_frame : int\n        _description_\n    elements : np.ndarray\n        _description_\n    coords : np.ndarray\n        XYZ coordinates of atoms, shape (n_atoms, 3).\n    cut_off : float\n        Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom.\n    bin_count : int, optional\n        Number of bins, by default None\n    bin_precision : float, optional\n        Bin precision, by default None\n\n    Returns\n    -------\n    dict\n        Dictionary containing as keys the element for which the rdf has been computed and as value two arrays, one continaing the bineed distance\n        the other containg the computed RDF.\n\n    Raises\n    ------\n    ValueError\n        Raised if the user does not specify either the bin_count or the bin_precision.\n    \"\"\"\n    unique_elements, n_elements = np.unique(elements, return_counts=True)\n    rdf_dict = {}\n    elements = np.array(elements)\n    hull = ConvexHull(coords)\n    box_volume = hull.volume\n    for el in unique_elements:\n\n        idx_el = np.where(elements == str(el))[0]\n        coords_el = np.array(coords[idx_el])\n\n        if bin_count:\n            d_el, rdf_el = rdf_calculator(index_frame=index_frame, coords=coords_el, cut_off = cut_off, bin_count=bin_count, box_volume = box_volume)\n        elif bin_precision:\n            d_el, rdf_el = rdf_calculator(index_frame=index_frame, coords=coords_el, cut_off = cut_off, bin_precision=bin_precision, box_volume = box_volume)\n        else:\n            raise ValueError(\"Either bin_count or bin_precision must be provided.\")\n\n        rdf_dict[el] = [d_el, rdf_el]\n    d_tot, rdf_tot = rdf_calculator(index_frame=index_frame, coords=coords, cut_off = cut_off, bin_count=bin_count)\n    rdf_dict[\"Tot\"] = [d_tot, rdf_tot]\n    return rdf_dict\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.pddf_calculator","title":"<code>pddf_calculator(index_frame, coords, bin_precision=None, bin_count=None)</code>","text":"<p>Computes the pair distance distribution function for a given set of coordinates of atoms. </p> <p>The user can either provide a bin precision or the numer of bins depending on wheter they are striving for a specific precision in the bins or on a specific number of bins for representation.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.pddf_calculator--parameters","title":"Parameters","text":"<p>index_frame : int     Index of the frame relative to the snapshot, primarily for reference. coords : ndarray     Array of the coordinates of the atoms forming the system. bin_precision: float, optional     Specify a value if you want to compute the PDDF with a given bin precision (in Angstrom) bin_count: int, optional     Specify a value if you want to compute the PDDF with a given number of bins</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.pddf_calculator--returns","title":"Returns","text":"<p>tuple     - ndarray: the values of the interatomic distances for each bin     - ndarray: the number of atoms within a given distance for each bin</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def pddf_calculator(index_frame, coords, bin_precision=None, bin_count=None):\n    \"\"\"\n    Computes the pair distance distribution function for a given set of coordinates of atoms. \\n\n    The user can either provide a bin precision or the numer of bins depending on wheter they are striving for a specific precision in the bins\n    or on a specific number of bins for representation.\n\n    Parameters\n    ----------\n    index_frame : int\n        Index of the frame relative to the snapshot, primarily for reference.\n    coords : ndarray\n        Array of the coordinates of the atoms forming the system.\n    bin_precision: float, optional\n        Specify a value if you want to compute the PDDF with a given bin precision (in Angstrom)\n    bin_count: int, optional\n        Specify a value if you want to compute the PDDF with a given number of bins\n\n    Returns\n    -------\n    tuple\n        - ndarray: the values of the interatomic distances for each bin\n        - ndarray: the number of atoms within a given distance for each bin\n\n    \"\"\"\n    n_atoms = np.shape(coords)[0]\n    dist_mat, dist_max, dist_min = distance_matrix(\n        index_frame=index_frame, coords=coords\n    )\n\n    triu_indeces = np.triu_indices(n_atoms, k=1)\n    distances = dist_mat[triu_indeces]\n    if bin_precision:\n        n_bins = int(np.ceil(dist_max / bin_precision))\n    elif bin_count:\n        n_bins = bin_count\n        bin_precision = dist_max / n_bins\n    else:\n        raise ValueError(\"You must specify either bin_precision or bin_count.\")\n\n    bins = np.linspace(0, dist_max, n_bins + 1)\n    dist_count, _ = np.histogram(distances, bins=bins)\n\n    return bins[:-1] + bin_precision / 2, dist_count\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.pddf_calculator_by_element","title":"<code>pddf_calculator_by_element(index_frame, coords, elements, element='Au', bin_precision=None, bin_count=None)</code>","text":"<p>Computes the pair distance distribution function (PDDF) for a given set of coordinates, considering only atoms of a specified chemical element.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.pddf_calculator_by_element--parameters","title":"Parameters","text":"<p>index_frame : int     Index of the frame relative to the snapshot, primarily for reference. coords : ndarray     Array of the coordinates of the atoms forming the system. elements : list     List of atomic species corresponding to each coordinate. element: str, optional     The atomic species to consider (default is 'Au'). bin_precision: float, optional     Bin precision in Angstroms. bin_count: int, optional     Number of bins. Returns</p> <p>tuple     - ndarray: the values of the interatomic distances for each bin     - ndarray: the number of atoms within a given distance for each bin</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def pddf_calculator_by_element(index_frame, coords, elements, element='Au', bin_precision=None, bin_count=None):\n    \"\"\"\n    Computes the pair distance distribution function (PDDF) for a given set of coordinates,\n    considering only atoms of a specified chemical element.\n\n    Parameters\n    ----------\n    index_frame : int\n        Index of the frame relative to the snapshot, primarily for reference.\n    coords : ndarray\n        Array of the coordinates of the atoms forming the system.\n    elements : list\n        List of atomic species corresponding to each coordinate.\n    element: str, optional\n        The atomic species to consider (default is 'Au').\n    bin_precision: float, optional\n        Bin precision in Angstroms.\n    bin_count: int, optional\n        Number of bins.\n    Returns\n    -------\n    tuple\n        - ndarray: the values of the interatomic distances for each bin\n        - ndarray: the number of atoms within a given distance for each bin\n    \"\"\"\n    # Select only the indices of the atoms corresponding to the specified element\n\n    selected_indices = [i for i, el in enumerate(elements) if el == element]\n    selected_coords = coords[selected_indices]\n\n    n_atoms = len(selected_indices)\n    if n_atoms &lt; 2:\n        raise ValueError(\"Not enough atoms of the specified element to compute PDDF.\")\n\n    dist_mat, dist_max, _ = distance_matrix(index_frame=index_frame, coords=selected_coords)\n\n    if bin_precision:\n        n_bins = dist_max / bin_precision\n    else:\n        n_bins = bin_count\n        bin_precision = dist_max / n_bins\n\n    n_bins_int = int(n_bins)\n    dist_count = np.zeros(n_bins_int)\n    dist = np.zeros(n_bins_int)\n\n    for i in range(n_bins_int):\n        for j in range(n_atoms):\n            for k in range(n_atoms):\n                if j != k and (dist_mat[j, k] &lt; bin_precision * i and dist_mat[j, k] &gt;= (bin_precision * (i - 1))):\n                    dist_count[i] += 1\n        dist[i] = bin_precision * i\n\n    return dist, dist_count\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.rdf_calculator","title":"<code>rdf_calculator(index_frame, coords, cut_off, bin_count=None, bin_precision=None, box_volume=None)</code>","text":""},{"location":"lodispp/utils/#snow.lodispp.utils.rdf_calculator--parameters","title":"Parameters","text":"<p>index_frame : int     description elements : np.ndarray     description coords : np.ndarray     XYZ coordinates of atoms, shape (n_atoms, 3). cut_off : float     Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom. bin_count : int, optional     Number of bins, by default None bin_precision : float, optional     Bin precision, by default None box_volume = None: float, optional     Box dimension for PBC (WIP), by default None (no PBC, good for isolated systems)</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.rdf_calculator--returns","title":"Returns","text":"<p>tuple[np.ndarray, np.ndarray]     Binned distance and rdf</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.rdf_calculator--raises","title":"Raises","text":"<p>ValueError     description</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def rdf_calculator(index_frame: int, \n                   coords: np.ndarray, \n                   cut_off: float, \n                   bin_count: int = None, \n                   bin_precision: float = None, \n                   box_volume = None) -&gt; tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n\n    Parameters\n    ----------\n    index_frame : int\n        _description_\n    elements : np.ndarray\n        _description_\n    coords : np.ndarray\n        XYZ coordinates of atoms, shape (n_atoms, 3).\n    cut_off : float\n        Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom.\n    bin_count : int, optional\n        Number of bins, by default None\n    bin_precision : float, optional\n        Bin precision, by default None\n    box_volume = None: float, optional\n        Box dimension for PBC (WIP), by default None (no PBC, good for isolated systems)\n\n    Returns\n    -------\n    tuple[np.ndarray, np.ndarray]\n        Binned distance and rdf\n\n    Raises\n    ------\n    ValueError\n        _description_\n    \"\"\"\n    n_atoms = len(coords)\n\n    # Determine binning parameters\n    if bin_count is None:\n        if bin_precision is not None:\n            bin_count = int(cut_off / bin_precision)\n        else:\n            raise ValueError(\"Either bin_count or bin_precision must be specified.\")\n\n    bin_edges = np.linspace(0, cut_off, bin_count + 1)\n    bin_centers = 0.5 * (bin_edges[:-1] + bin_edges[1:])\n    rdf = np.zeros(bin_count)\n\n    # Build KD-tree and get all unique pairs\n    tree = cKDTree(coords)\n    pairs = tree.query_pairs(cut_off, output_type=\"ndarray\")  # Unique pairs, excludes self\n\n    # Compute distances only for valid pairs\n    distances = np.linalg.norm(coords[pairs[:, 0]] - coords[pairs[:, 1]], axis=1)\n\n    # Bin distances\n    counts, _ = np.histogram(distances, bins=bin_edges)\n    rdf += counts * 2  # Multiply by 2 since each pair is counted once\n\n    # Normalize RDF\n    shell_volumes = (4 / 3) * np.pi * (bin_edges[1:]**3 - bin_edges[:-1]**3)\n    if box_volume == None:\n        hull = ConvexHull(coords)\n        box_volume = hull.volume\n\n    number_density = n_atoms / box_volume\n    #rdf = rdf / (number_density * shell_volumes * n_atoms)\n    rdf = rdf / (number_density * shell_volumes * n_atoms)\n    return bin_centers, rdf\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.second_neighbours","title":"<code>second_neighbours(index_frame, coords, cutoff)</code>","text":"<p>Generates a list of lists of atomic indeces for each atom corresponding to aotoms that are neighbours of first neighbours  excluding those which are already first neighbours. </p>"},{"location":"lodispp/utils/#snow.lodispp.utils.second_neighbours--parameters","title":"Parameters","text":"<p>index_frame : int     Index of the frame if a movie (not used in the current version but can be useful for dynamic systems). coords : np.ndarray     Array with the XYZ coordinates of the atoms, shape (n_atoms, 3). cutoff : float     Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.second_neighbours--returns","title":"Returns","text":"<p>list     List of lists containing indeces of second neighbours for each atom</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def second_neighbours(index_frame: int, coords: np.ndarray, cutoff: float) -&gt; list:\n    \"\"\"Generates a list of lists of atomic indeces for each atom corresponding to aotoms that are neighbours of first neighbours \n    excluding those which are already first neighbours. \n\n    Parameters\n    ----------\n    index_frame : int\n        Index of the frame if a movie (not used in the current version but can be useful for dynamic systems).\n    coords : np.ndarray\n        Array with the XYZ coordinates of the atoms, shape (n_atoms, 3).\n    cutoff : float\n        Cutoff distance for finding pairs in angstroms. If None, an adaptive cutoff is used per atom.\n\n    Returns\n    -------\n    list\n        List of lists containing indeces of second neighbours for each atom\n    \"\"\"\n    neigh = nearest_neighbours(index_frame=index_frame, coords=coords, cut_off=cutoff)\n    snn_list = []\n    n_atoms = np.shape(coords)[0]\n    for i in range(n_atoms):\n        temp_snn = []\n        for j in neigh[i]:\n            int_ij = np.intersect1d(neigh[i], neigh[j], assume_unique=True)\n            snn_ij = np.setdiff1d(neigh[j], int_ij, assume_unique=True).tolist()\n            temp_snn.extend(snn_ij)\n        temp_snn = list(dict.fromkeys(temp_snn))\n        snn_list.append(temp_snn)\n\n    return snn_list\n</code></pre>"},{"location":"lodispp/utils/#snow.lodispp.utils.sparse_adjacency_matrix","title":"<code>sparse_adjacency_matrix(index_frame, coords, cutoff)</code>","text":"<p>Create a sparse adjacency matrix where entries are 1 if the distance between points is less than or equal to the cutoff.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.sparse_adjacency_matrix--parameters","title":"Parameters","text":"<p>index_frame : int     Number of the frame if a movie. coords: ndarray     Array with the XYZ coordinates of the atoms, shape (n_atoms, 3). cut_off : float     Cutoff distance for finding neighbors in angstrom.</p>"},{"location":"lodispp/utils/#snow.lodispp.utils.sparse_adjacency_matrix--returns","title":"Returns","text":"<p>ndarray     A sparse adjacency matrix with ones for adjacent points.</p> Source code in <code>snow/lodispp/utils.py</code> <pre><code>def sparse_adjacency_matrix(index_frame, coords, cutoff):\n    \"\"\"\n    Create a sparse adjacency matrix where entries are 1 if the distance between points\n    is less than or equal to the cutoff.\n\n    Parameters\n    ----------\n    index_frame : int\n        Number of the frame if a movie.\n    coords: ndarray\n        Array with the XYZ coordinates of the atoms, shape (n_atoms, 3).\n    cut_off : float\n        Cutoff distance for finding neighbors in angstrom.\n\n    Returns\n    -------\n    ndarray\n        A sparse adjacency matrix with ones for adjacent points.\n    \"\"\"\n    # Create a KDTree for efficient distance queries\n    tree = cKDTree(coords)\n\n    # Get pairs of points within the cutoff distance\n    pairs = tree.sparse_distance_matrix(tree, cutoff).keys()\n\n    # Extract row and column indices from pairs\n    rows, cols = zip(*pairs)\n\n    # Create a sparse adjacency matrix with ones\n    adjacency_matrix = coo_matrix((len(coords), len(coords)), shape=(len(coords), len(coords)))\n    adjacency_matrix = coo_matrix((np.ones(len(rows), dtype=int), (rows, cols)))\n\n    return adjacency_matrix\n</code></pre>"}]}